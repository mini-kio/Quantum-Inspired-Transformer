            # 레이어 결과 업데이트
            deterministic_state = layer_result['deterministic_state']
            superposition_state = layer_result['superposition_state']
            
            # 불확실성 정보 저장
            if 'uncertainty' in layer_result:
                uncertainties.append(layer_result['uncertainty'])
            
            # 전환 확률 정보 저장
            if 'transition_prob' in layer_result:
                transition_probs.append(layer_result['transition_prob'])
                
            # 리소스 효율성 정보 저장
            if 'resource_efficiency' in layer_result:
                resource_efficiencies.append(layer_result.get('resource_efficiency', torch.tensor(0.0)))
            
            # 레이어 상태 저장
            layer_deterministic_states.append(deterministic_state)
            layer_superposition_states.append(superposition_state)
            
            # 필요한 경우 중간 상태 붕괴
            if (i + 1) % 4 == 0 and i < self.num_layers - 1:
                # 상태 붕괴 프레임워크 적용
                collapse_result = self.collapse_framework(
                    superposition_state=superposition_state,
                    context=context,
                    previous_state=previous_state,
                    hidden_state=hidden_state,
                    force_collapse=False,  # 중간 레이어는 조건부 붕괴
                    layer_id=i,            # 레이어 ID 전달
                    num_layers=self.num_layers,  # 총 레이어 수 전달
                    p_target=p_target      # 목표 전환 확률 전달
                )
                
                # 붕괴 조건이 충족된 위치만 벡터화하여 업데이트
                collapse_mask = collapse_result['collapse_condition'].bool()  # [B,S,1]
                mask_expanded = collapse_mask.expand(-1, -1, self.d_model)
                deterministic_state = torch.where(
                    mask_expanded,
                    collapse_result['collapsed_state'],
                    deterministic_state
                )
                
                # 상태 및 히든 상태 업데이트
                previous_state = superposition_state.clone()
                hidden_state = collapse_result['hidden_state']
                
                # 붕괴 이후 새 중첩 상태 생성
                superposition_state = self.dual_state_system.to_superposition_state(
                    deterministic_state, context
                )
        
        # 글로벌 상태 관리 적용
        managed_superposition_states = self.state_manager(layer_superposition_states)
        
        # 계층적 상태 프로토콜 적용 (마지막 상태에만)
        hierarchical_state = self.hierarchical_protocol(managed_superposition_states[-1])
        
        # 최종 상태 붕괴 (강제 또는 마지막 레이어)
        if force_collapse:
            # 동적 붕괴 컨트롤러 적용
            collapse_result = self.collapse_controller(
                superposition_state=hierarchical_state,
                deterministic_state=layer_deterministic_states[-1],
                context=context,
                p_target=p_target  # 목표 전환 확률 전달
            )
            final_deterministic = collapse_result['collapsed_state']
        else:
            # 표준 붕괴 프레임워크 적용
            collapse_result = self.collapse_framework(
                superposition_state=hierarchical_state,
                context=context,
                previous_state=previous_state,
                hidden_state=hidden_state,
                force_collapse=True,  # 마지막 레이어는 강제 붕괴
                layer_id=self.num_layers-1,  # 레이어 ID 전달
                num_layers=self.num_layers,  # 총 레이어 수 전달
                p_target=p_target  # 목표 전환 확률 전달
            )
            final_deterministic = collapse_result['collapsed_state']
        
        # 정규화 적용
        output = self.norm(final_deterministic)
        
        # 통합 추론 엔진 적용
        inference_result = self.inference_engine(
            deterministic_state=output,
            superposition_state=hierarchical_state,
            context=context
        )
        
        # 다중 가설 트래킹 업데이트
        hypothesis_result = self.hypothesis_tracker(
            new_hypothesis=inference_result['result'].mean(dim=1),
            context=context
        )
        
        if return_all_states:
            # 평균 불확실성, 전환 확률, 리소스 효율성 계산
            avg_uncertainty = torch.cat(uncertainties).mean() if uncertainties else torch.tensor(0.0)
            avg_transition_prob = torch.cat(transition_probs).mean() if transition_probs else torch.tensor(0.0)
            avg_resource_efficiency = torch.tensor(
                sum([eff.item() for eff in resource_efficiencies]) / len(resource_efficiencies)
                if resource_efficiencies else 0.0
            )
            
            return {
                'output': output,
                'inference_result': inference_result['result'],
                'superposition_state': hierarchical_state,
                'deterministic_states': layer_deterministic_states,
                'superposition_states': managed_superposition_states,
                'collapse_result': collapse_result,
                'hypothesis': hypothesis_result['combined_hypothesis'],
                'uncertainty': avg_uncertainty,  # 평균 불확실성 추가
                'transition_prob': avg_transition_prob,  # 평균 전환 확률 추가
                'resource_efficiency': avg_resource_efficiency,  # 평균 리소스 효율성 추가
                'gate_result': collapse_result.get('gate_result', {})  # CollapseGate 결과 추가
            }
        else:
            return output


class QuantumInspiredTransformerDecoder(nn.Module):
    """
    양자 영감 트랜스포머 디코더
    """
    
    def __init__(
        self,
        d_model: int = 768,
        nhead: int = 12,
        num_layers: int = 12,
        dim_feedforward: int = 3072,
        dropout: float = 0.1,
        max_superposition_dim: int = 4,
        activation: str = "gelu",
        gate_type: str = "mlp"  # "mlp" 또는 "transformer"
    ):
        """
        양자 영감 트랜스포머 디코더 초기화
        
        Args:
            d_model (int): 모델 차원
            nhead (int): 어텐션 헤드 수
            num_layers (int): 디코더 레이어 수
            dim_feedforward (int): 피드포워드 네트워크 차원
            dropout (float): 드롭아웃 비율
            max_superposition_dim (int): 최대 중첩 상태 차원
            activation (str): 활성화 함수 유형
            gate_type (str): CollapseGate 유형
        """
        super().__init__()
        
        self.d_model = d_model
        self.nhead = nhead
        self.num_layers = num_layers
        self.max_superposition_dim = max_superposition_dim
        self.gate_type = gate_type
        
        # 이중 상태 표현 시스템
        self.dual_state_system = DualStateRepresentation(
            hidden_dim=d_model,
            max_superposition_dim=max_superposition_dim
        )
        
        # 이중 상태 컨트롤러
        self.state_controller = DualStateController(hidden_dim=d_model)
        
        # 위치 인코딩
        self.position_encoding = PositionalEncoding(d_model=d_model, dropout=dropout)
        self.quantum_position_encoding = QuantumPositionalEncoding(
            d_model=d_model, 
            max_superposition_dim=max_superposition_dim, 
            dropout=dropout
        )
        
        # 디코더 레이어
        self.layers = nn.ModuleList([
            IntegratedDecoderLayer(
                d_model=d_model,
                nhead=nhead,
                dim_feedforward=dim_feedforward,
                dropout=dropout,
                max_superposition_dim=max_superposition_dim,
                activation=activation,
                layer_id=i,  # 레이어 ID 추가
                num_layers=num_layers,  # 총 레이어 수 추가
                gate_type=gate_type  # CollapseGate 유형 추가
            ) for i in range(num_layers)
        ])
        
        # 글로벌 상태 관리 엔진
        self.state_manager = GlobalStateManager(
            hidden_dim=d_model,
            num_layers=num_layers,
            max_superposition_dim=max_superposition_dim
        )
        
        # 계층적 상태 프로토콜
        self.hierarchical_protocol = HierarchicalStateProtocol(
            hidden_dim=d_model,
            max_superposition_dim=max_superposition_dim
        )
        
        # 상태 붕괴 프레임워크
        self.collapse_framework = StateCollapseFramework(
            hidden_dim=d_model,
            max_superposition_dim=max_superposition_dim
        )
        
        # 동적 붕괴 컨트롤러
        self.collapse_controller = DynamicCollapseController(
            hidden_dim=d_model,
            max_superposition_dim=max_superposition_dim
        )
        
        # 추론 깊이 어댑터
        self.reasoning_depth_adapter = ReasoningDepthAdapter(hidden_dim=d_model)
